from db_utils import init_db, get_uuid_by_tg_id, save_user, get_expiry_by_tg_id, update_expiry_in_db
from flask import Flask, request, jsonify, redirect
from datetime import datetime, timedelta
import uuid
import requests
import time
import json
import logging
import traceback


app = Flask(__name__)


# === –ö–æ–Ω—Ñ–∏–≥–∏ ===
API_BASE = "http://178.62.198.20:54321/P2kGNvqkhq9dDt2/panel/api"
LOGIN = "UxslbEu81t"
PASSWORD = "kHWi2UbCWE"
DOMAIN = "178.62.198.20"
PORT = 34913
PUBLIC_KEY = "uvnOU3LMB65JPi891aar91sfn6DaloFioVbd2TWbTGM"

logging.basicConfig(level=logging.INFO)


def get_cookie():
    payload = {"username": LOGIN, "password": PASSWORD}
    r = requests.post(API_BASE.replace("/panel/api", "/login"), data=payload)
    if r.status_code == 200:
        print("‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞")
        return r.cookies.get_dict()
    raise Exception("‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: " + r.text)


@app.route("/generate-key", methods=["POST"])
def generate_key():
    tg_id = request.json.get("tg_id")
    if not tg_id:
        return jsonify({"error": "Telegram ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω"}), 400

    # –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å—Ç—å –ª–∏ —É–∂–µ –∫–ª—é—á
    existing_uuid = get_uuid_by_tg_id(tg_id)
    if existing_uuid:
        vless_url = f"vless://{existing_uuid}@{DOMAIN}:{PORT}?type=tcp&security=reality&flow=xtls-rprx-vision&sni=yahoo.com&fp=chrome&pbk={PUBLIC_KEY}&sid=07&spx=%2F#PlatformVPN"

        # —Å–æ—Ö—Ä–∞–Ω—è–µ–º .txt –¥–ª—è —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ UUID
    try:
        config_path = f"/var/www/html/configs/{existing_uuid}.txt"
        with open(config_path, "w") as f:
            f.write(vless_url)
        logging.info(f"‚úÖ –ö–æ–Ω—Ñ–∏–≥ –¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ UUID —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {config_path}")
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ VLESS-—Ñ–∞–π–ª–∞: {e}")

    return jsonify({
        "success": True,
        "uuid": existing_uuid,
        "vless_url": vless_url
    })

    try:
        logging.info(f"üöÄ –ó–∞–ø—Ä–æ—Å –Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∫–ª—é—á–∞ –¥–ª—è tg_id: {tg_id}")
        cookies = get_cookie()
        logging.info("‚úÖ –ö—É–∫–∏ –ø–æ–ª—É—á–µ–Ω—ã")

        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ inbounds
        r = requests.get(f"{API_BASE}/inbounds/list", cookies=cookies)
        logging.info("üì° –ó–∞–ø—Ä–æ—à–µ–Ω—ã inbounds")
        if r.status_code != 200:
            return jsonify({"error": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ inbounds"}), 500

        inbounds = r.json().get("obj", [])
        inbound = next((i for i in inbounds if i.get("port") == PORT), None)
        if not inbound:
            return jsonify({"error": f"Inbound —Å –ø–æ—Ä—Ç–æ–º {PORT} –Ω–µ –Ω–∞–π–¥–µ–Ω"}), 404

        inbound_id = inbound.get("id")
        logging.info(f"‚úÖ –ù–∞–π–¥–µ–Ω inbound: {inbound_id}")

        settings = inbound.get("settings")
        if isinstance(settings, str):
            settings = json.loads(settings)

        clients = settings.get("clients", [])

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–ª–∏–µ–Ω—Ç–∞
        user_uuid = str(uuid.uuid4())
        expiry_timestamp = (int(time.time()) + 2 * 24 * 60 * 60) * 1000

        new_client = {
            "id": user_uuid,
            "flow": "xtls-rprx-vision",
            "email": f"{tg_id}@vpn",
            "limitIp": 0,
            "totalGB": 0,
            "expiryTime": expiry_timestamp,
            "enable": True
        }

        clients.append(new_client)
        settings["clients"] = clients
        settings["decryption"] = "none"

        # –°–æ–±–∏—Ä–∞–µ–º –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π payload
        payload = {
            "remark": inbound.get("remark"),
            "listen": inbound.get("listen", ""),
            "port": PORT,
            "protocol": inbound.get("protocol"),
            "settings": json.dumps(settings),
            "streamSettings": inbound.get("streamSettings"),
            "sniffing": inbound.get("sniffing"),
            "allocate": inbound.get("allocate", json.dumps({})),
            "enable": True
        }

        update_url = f"{API_BASE}/inbounds/update/{inbound_id}"
        logging.info(f"üì§ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ inbound ID: {inbound_id}")
        update_r = requests.post(update_url, data=payload, cookies=cookies)
        logging.info(f"üì• –û—Ç–≤–µ—Ç –æ—Ç 3x-ui: {update_r.status_code} {update_r.text}")

        if update_r.status_code != 200 or not update_r.json().get("success", False):
            return jsonify({
                "error": "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ inbound",
                "details": update_r.text
            }), 500

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
        save_user(tg_id, user_uuid, expiry_timestamp)

        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Å—ã–ª–∫–∏
        vless_url = (
            f"vless://{user_uuid}@{DOMAIN}:{PORT}"
            f"?type=tcp&security=reality&flow=xtls-rprx-vision"
            f"&sni=yahoo.com&fp=chrome&pbk={PUBLIC_KEY}&sid=07&spx=%2F#PlatformVPN"
        )

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º .txt
        try:
            config_path = f"/var/www/html/configs/{user_uuid}.txt"
            with open(config_path, "w") as f:
                f.write(vless_url)
            logging.info(f"‚úÖ –ö–æ–Ω—Ñ–∏–≥ –¥–ª—è –Ω–æ–≤–æ–≥–æ UUID —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {config_path}")
        except Exception as e:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ VLESS-—Ñ–∞–π–ª–∞: {e}")

        return jsonify({
            "success": True,
            "uuid": user_uuid,
            "vless_url": vless_url
        })

    except Exception as e:
        logging.exception("üí• –û—à–∏–±–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª–∏–µ–Ω—Ç–∞")
        return jsonify({
            "error": "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–ª–∏–µ–Ω—Ç–∞",
            "details": str(e),
            "trace": traceback.format_exc()
        }), 500


init_db()


@app.route('/payment-success', methods=['POST'])
def payment_success():
    # 1. –ß–∏—Ç–∞–µ–º JSON –∏ –≤–∞–ª–∏–¥–∏—Ä—É–µ–º
    data = request.get_json(force=True)
    logging.info(f"üì© JSON DATA: {data}")

    if not data:
        return jsonify({"error": "No JSON payload received"}), 400

    tg_id = data.get("object", {}).get("metadata", {}).get("tg_id")
    duration_days = data.get("object", {}).get(
        "metadata", {}).get("duration_days")

    if not tg_id or not duration_days:
        return jsonify({"error": "Missing 'tg_id' or 'duration_days'"}), 400

    try:
        existing_uuid = get_uuid_by_tg_id(tg_id)
        cookies = get_cookie()
        expiry_timestamp = int(
            (datetime.utcnow() + timedelta(days=int(duration_days))).timestamp() * 1000
        )

        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ inbounds
        r = requests.get(f"{API_BASE}/inbounds/list", cookies=cookies)
        response_text = r.text
        logging.info(f"üì° –û—Ç–≤–µ—Ç –æ—Ç /inbounds/list: —Å—Ç–∞—Ç—É—Å {r.status_code}")
        logging.info("üì¶ –°—ã—Ä–æ–π –æ—Ç–≤–µ—Ç –æ—Ç 3x-ui:")
        logging.info(response_text)

        try:
            inbounds = json.loads(response_text)["obj"]
        except Exception:
            logging.exception("‚ùå –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π JSON –æ—Ç /inbounds/list")
            return jsonify({"error": "Invalid JSON from 3x-ui"}), 502

        inbound = next((i for i in inbounds if i.get("port") == PORT), None)
        if not inbound:
            return jsonify({"error": f"Inbound —Å –ø–æ—Ä—Ç–æ–º {PORT} –Ω–µ –Ω–∞–π–¥–µ–Ω"}), 404

        inbound_id = inbound.get("id")
        settings = inbound.get("settings")
        if isinstance(settings, str):
            settings = json.loads(settings)

        clients = settings.get("clients", [])

        if not existing_uuid:
            # –ö–ª–∏–µ–Ω—Ç–∞ –Ω–µ—Ç ‚Äî —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–≥–æ
            new_uuid = str(uuid.uuid4())

            new_client = {
                "id": new_uuid,
                "flow": "xtls-rprx-vision",
                "email": tg_id,
                "limitIp": 0,
                "totalGB": 0,
                "expiryTime": expiry_timestamp,
                "enable": True
            }

            clients.append(new_client)
            settings["clients"] = clients
            settings["decryption"] = "none"

            update_payload = {
                "remark": inbound.get("remark"),
                "listen": inbound.get("listen", ""),
                "port": PORT,
                "protocol": inbound.get("protocol"),
                "settings": json.dumps(settings),
                "streamSettings": inbound.get("streamSettings"),
                "sniffing": inbound.get("sniffing"),
                "allocate": inbound.get("allocate", json.dumps({})),
                "enable": True
            }

            update_url = f"{API_BASE}/inbounds/update/{inbound_id}"
            update_r = requests.post(
                update_url, data=update_payload, cookies=cookies)
            logging.info(
                f"üì• –û—Ç–≤–µ—Ç –æ—Ç 3x-ui: {update_r.status_code} {update_r.text}")

            save_user(tg_id, new_uuid, expiry_timestamp)
            return jsonify({"message": "‚úÖ –ö–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–Ω –∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω"}), 200

        else:
            # –ö–ª–∏–µ–Ω—Ç –µ—Å—Ç—å ‚Äî –ø—Ä–æ–¥–ª–µ–≤–∞–µ–º
            user_uuid = existing_uuid
            current_expiry = get_expiry_by_tg_id(tg_id)
            new_expiry = datetime.utcnow() + timedelta(days=int(duration_days))

            if current_expiry and current_expiry > datetime.utcnow():
                new_expiry = current_expiry + \
                    timedelta(days=int(duration_days))

            new_expiry_ts = int(new_expiry.timestamp() * 1000)

            for client in clients:
                if client["id"] == user_uuid:
                    client["expiryTime"] = new_expiry_ts
                    client["enable"] = True
                    client["email"] = f"{tg_id}@vpn#{int(time.time())}"

            settings["clients"] = clients
            settings["decryption"] = "none"

            update_payload = {
                "remark": inbound.get("remark"),
                "listen": inbound.get("listen", ""),
                "port": PORT,
                "protocol": inbound.get("protocol"),
                "settings": json.dumps(settings),
                "streamSettings": inbound.get("streamSettings"),
                "sniffing": inbound.get("sniffing"),
                "allocate": inbound.get("allocate", json.dumps({})),
                "enable": True
            }

            update_url = f"{API_BASE}/inbounds/update/{inbound_id}"
            update_r = requests.post(
                update_url, data=update_payload, cookies=cookies)
            logging.info(
                f"üì• –û—Ç–≤–µ—Ç –æ—Ç 3x-ui: {update_r.status_code} {update_r.text}")

            update_expiry_in_db(tg_id, new_expiry)
            return jsonify({"message": "‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–¥–ª–µ–Ω–∞"}), 200

    except Exception as e:
        logging.error(f"üí• –û—à–∏–±–∫–∞ –≤ /payment-success: {e}")
        return jsonify({"error": str(e)}), 500


# === –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è inbound ===
def update_inbound(cookies, payload):
    response = requests.post(
        f"{API_BASE}/inbounds/update", cookies=cookies, json=payload)
    if response.status_code != 200:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è inbound: {response.text}")
        raise Exception("–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è inbound")


@app.route("/redirect")
def redirect_to_scheme():
    url = request.args.get("url")
    if url:
        return redirect(url)
    return "‚ùå –ù–µ—Ç URL –¥–ª—è —Ä–µ–¥–∏—Ä–µ–∫—Ç–∞", 400


if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=5001)
